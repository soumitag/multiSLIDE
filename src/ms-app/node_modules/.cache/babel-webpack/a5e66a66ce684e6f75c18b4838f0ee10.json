{"ast":null,"code":"import _get from \"/Users/soumitaghosh/Documents/GitHub/multi-slide/src/ms-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/soumitaghosh/Documents/GitHub/multi-slide/src/ms-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createForOfIteratorHelper from \"/Users/soumitaghosh/Documents/GitHub/multi-slide/src/ms-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _inherits from \"/Users/soumitaghosh/Documents/GitHub/multi-slide/src/ms-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/soumitaghosh/Documents/GitHub/multi-slide/src/ms-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _toConsumableArray from \"/Users/soumitaghosh/Documents/GitHub/multi-slide/src/ms-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/soumitaghosh/Documents/GitHub/multi-slide/src/ms-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/soumitaghosh/Documents/GitHub/multi-slide/src/ms-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { SelectionModel, isDataSource } from '@angular/cdk/collections';\nimport { isObservable, Subject, BehaviorSubject, of } from 'rxjs';\nimport { take, filter, takeUntil } from 'rxjs/operators';\nimport { InjectionToken, Directive, ViewContainerRef, Inject, Optional, TemplateRef, Component, ViewEncapsulation, ChangeDetectionStrategy, IterableDiffers, ChangeDetectorRef, Input, ViewChild, ContentChildren, ElementRef, Renderer2, HostListener, NgModule } from '@angular/core';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceNumberProperty, coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { FocusMonitor } from '@angular/cdk/a11y';\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/control/base-tree-control.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Base tree control. It has basic toggle/expand/collapse operations on a single data node.\n * @abstract\n * @template T, K\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/bidi';\n\nvar BaseTreeControl = /*#__PURE__*/function () {\n  function BaseTreeControl() {\n    _classCallCheck(this, BaseTreeControl);\n\n    /**\n     * A selection model with multi-selection to track expansion status.\n     */\n    this.expansionModel = new SelectionModel(true);\n  }\n  /**\n   * Toggles one single data node's expanded/collapsed state.\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n\n  _createClass(BaseTreeControl, [{\n    key: \"toggle\",\n    value: function toggle(dataNode) {\n      this.expansionModel.toggle(this._trackByValue(dataNode));\n    }\n    /**\n     * Expands one single data node.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"expand\",\n    value: function expand(dataNode) {\n      this.expansionModel.select(this._trackByValue(dataNode));\n    }\n    /**\n     * Collapses one single data node.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"collapse\",\n    value: function collapse(dataNode) {\n      this.expansionModel.deselect(this._trackByValue(dataNode));\n    }\n    /**\n     * Whether a given data node is expanded or not. Returns true if the data node is expanded.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"isExpanded\",\n    value: function isExpanded(dataNode) {\n      return this.expansionModel.isSelected(this._trackByValue(dataNode));\n    }\n    /**\n     * Toggles a subtree rooted at `node` recursively.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"toggleDescendants\",\n    value: function toggleDescendants(dataNode) {\n      this.expansionModel.isSelected(this._trackByValue(dataNode)) ? this.collapseDescendants(dataNode) : this.expandDescendants(dataNode);\n    }\n    /**\n     * Collapse all dataNodes in the tree.\n     * @return {?}\n     */\n\n  }, {\n    key: \"collapseAll\",\n    value: function collapseAll() {\n      this.expansionModel.clear();\n    }\n    /**\n     * Expands a subtree rooted at given data node recursively.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandDescendants\",\n    value: function expandDescendants(dataNode) {\n      var _this$expansionModel,\n          _this = this;\n\n      /** @type {?} */\n      var toBeProcessed = [dataNode];\n      toBeProcessed.push.apply(toBeProcessed, _toConsumableArray(this.getDescendants(dataNode)));\n\n      (_this$expansionModel = this.expansionModel).select.apply(_this$expansionModel, _toConsumableArray(toBeProcessed.map(\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        return _this._trackByValue(value);\n      })));\n    }\n    /**\n     * Collapses a subtree rooted at given data node recursively.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"collapseDescendants\",\n    value: function collapseDescendants(dataNode) {\n      var _this$expansionModel2,\n          _this2 = this;\n\n      /** @type {?} */\n      var toBeProcessed = [dataNode];\n      toBeProcessed.push.apply(toBeProcessed, _toConsumableArray(this.getDescendants(dataNode)));\n\n      (_this$expansionModel2 = this.expansionModel).deselect.apply(_this$expansionModel2, _toConsumableArray(toBeProcessed.map(\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        return _this2._trackByValue(value);\n      })));\n    }\n    /**\n     * @protected\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"_trackByValue\",\n    value: function _trackByValue(value) {\n      return this.trackBy ? this.trackBy(\n      /** @type {?} */\n      value) :\n      /** @type {?} */\n      value;\n    }\n  }]);\n\n  return BaseTreeControl;\n}();\n\nif (false) {\n  /**\n   * Saved data node for `expandAll` action.\n   * @type {?}\n   */\n  BaseTreeControl.prototype.dataNodes;\n  /**\n   * A selection model with multi-selection to track expansion status.\n   * @type {?}\n   */\n\n  BaseTreeControl.prototype.expansionModel;\n  /**\n   * Returns the identifier by which a dataNode should be tracked, should its\n   * reference change.\n   *\n   * Similar to trackBy for *ngFor\n   * @type {?}\n   */\n\n  BaseTreeControl.prototype.trackBy;\n  /**\n   * Get depth of a given data node, return the level number. This is for flat tree node.\n   * @type {?}\n   */\n\n  BaseTreeControl.prototype.getLevel;\n  /**\n   * Whether the data node is expandable. Returns true if expandable.\n   * This is for flat tree node.\n   * @type {?}\n   */\n\n  BaseTreeControl.prototype.isExpandable;\n  /**\n   * Gets a stream that emits whenever the given data node's children change.\n   * @type {?}\n   */\n\n  BaseTreeControl.prototype.getChildren;\n  /**\n   * Gets a list of descendent data nodes of a subtree rooted at given data node recursively.\n   * @abstract\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n  BaseTreeControl.prototype.getDescendants = function (dataNode) {};\n  /**\n   * Expands all data nodes in the tree.\n   * @abstract\n   * @return {?}\n   */\n\n\n  BaseTreeControl.prototype.expandAll = function () {};\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/control/flat-tree-control.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Optional set of configuration that can be provided to the FlatTreeControl.\n * @record\n * @template T, K\n */\n\n\nfunction FlatTreeControlOptions() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  FlatTreeControlOptions.prototype.trackBy;\n}\n/**\n * Flat tree control. Able to expand/collapse a subtree recursively for flattened tree.\n * @template T, K\n */\n\n\nvar FlatTreeControl = /*#__PURE__*/function (_BaseTreeControl) {\n  _inherits(FlatTreeControl, _BaseTreeControl);\n\n  var _super = _createSuper(FlatTreeControl);\n\n  /**\n   * Construct with flat tree data node functions getLevel and isExpandable.\n   * @param {?} getLevel\n   * @param {?} isExpandable\n   * @param {?=} options\n   */\n  function FlatTreeControl(getLevel, isExpandable, options) {\n    var _this3;\n\n    _classCallCheck(this, FlatTreeControl);\n\n    _this3 = _super.call(this);\n    _this3.getLevel = getLevel;\n    _this3.isExpandable = isExpandable;\n    _this3.options = options;\n\n    if (_this3.options) {\n      _this3.trackBy = _this3.options.trackBy;\n    }\n\n    return _this3;\n  }\n  /**\n   * Gets a list of the data node's subtree of descendent data nodes.\n   *\n   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n   * with correct levels.\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n\n  _createClass(FlatTreeControl, [{\n    key: \"getDescendants\",\n    value: function getDescendants(dataNode) {\n      /** @type {?} */\n      var startIndex = this.dataNodes.indexOf(dataNode);\n      /** @type {?} */\n\n      var results = []; // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\n      // The level of descendants of a tree node must be greater than the level of the given\n      // tree node.\n      // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\n      // If we reach a node whose level is greater than the level of the tree node, we hit a\n      // sibling of an ancestor.\n\n      for (var i = startIndex + 1; i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]); i++) {\n        results.push(this.dataNodes[i]);\n      }\n\n      return results;\n    }\n    /**\n     * Expands all data nodes in the tree.\n     *\n     * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n     * data nodes of the tree.\n     * @return {?}\n     */\n\n  }, {\n    key: \"expandAll\",\n    value: function expandAll() {\n      var _this$expansionModel3,\n          _this4 = this;\n\n      (_this$expansionModel3 = this.expansionModel).select.apply(_this$expansionModel3, _toConsumableArray(this.dataNodes.map(\n      /**\n      * @param {?} node\n      * @return {?}\n      */\n      function (node) {\n        return _this4._trackByValue(node);\n      })));\n    }\n  }]);\n\n  return FlatTreeControl;\n}(BaseTreeControl);\n\nif (false) {\n  /** @type {?} */\n  FlatTreeControl.prototype.getLevel;\n  /** @type {?} */\n\n  FlatTreeControl.prototype.isExpandable;\n  /** @type {?} */\n\n  FlatTreeControl.prototype.options;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/control/nested-tree-control.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type.\n * @template T\n */\n\n\nvar NestedTreeControl = /*#__PURE__*/function (_BaseTreeControl2) {\n  _inherits(NestedTreeControl, _BaseTreeControl2);\n\n  var _super2 = _createSuper(NestedTreeControl);\n\n  /**\n   * Construct with nested tree function getChildren.\n   * @param {?} getChildren\n   */\n  function NestedTreeControl(getChildren) {\n    var _this5;\n\n    _classCallCheck(this, NestedTreeControl);\n\n    _this5 = _super2.call(this);\n    _this5.getChildren = getChildren;\n    return _this5;\n  }\n  /**\n   * Expands all dataNodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level\n   * data nodes of the tree.\n   * @return {?}\n   */\n\n\n  _createClass(NestedTreeControl, [{\n    key: \"expandAll\",\n    value: function expandAll() {\n      var _this6 = this,\n          _this$expansionModel4;\n\n      this.expansionModel.clear();\n      /** @type {?} */\n\n      var allNodes = this.dataNodes.reduce(\n      /**\n      * @param {?} accumulator\n      * @param {?} dataNode\n      * @return {?}\n      */\n      function (accumulator, dataNode) {\n        return [].concat(_toConsumableArray(accumulator), _toConsumableArray(_this6.getDescendants(dataNode)), [dataNode]);\n      }, []);\n\n      (_this$expansionModel4 = this.expansionModel).select.apply(_this$expansionModel4, _toConsumableArray(allNodes));\n    }\n    /**\n     * Gets a list of descendant dataNodes of a subtree rooted at given data node recursively.\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"getDescendants\",\n    value: function getDescendants(dataNode) {\n      /** @type {?} */\n      var descendants = [];\n\n      this._getDescendants(descendants, dataNode); // Remove the node itself\n\n\n      return descendants.splice(1);\n    }\n    /**\n     * A helper function to get descendants recursively.\n     * @protected\n     * @param {?} descendants\n     * @param {?} dataNode\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getDescendants\",\n    value: function _getDescendants(descendants, dataNode) {\n      var _this7 = this;\n\n      descendants.push(dataNode);\n      /** @type {?} */\n\n      var childrenNodes = this.getChildren(dataNode);\n\n      if (Array.isArray(childrenNodes)) {\n        childrenNodes.forEach(\n        /**\n        * @param {?} child\n        * @return {?}\n        */\n        function (child) {\n          return _this7._getDescendants(descendants, child);\n        });\n      } else if (isObservable(childrenNodes)) {\n        // TypeScript as of version 3.5 doesn't seem to treat `Boolean` like a function that\n        // returns a `boolean` specifically in the context of `filter`, so we manually clarify that.\n        childrenNodes.pipe(take(1), filter(\n        /** @type {?} */\n        Boolean)).subscribe(\n        /**\n        * @param {?} children\n        * @return {?}\n        */\n        function (children) {\n          var _iterator = _createForOfIteratorHelper(children),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var child = _step.value;\n\n              _this7._getDescendants(descendants, child);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n      }\n    }\n  }]);\n\n  return NestedTreeControl;\n}(BaseTreeControl);\n\nif (false) {\n  /** @type {?} */\n  NestedTreeControl.prototype.getChildren;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/control/tree-control.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Tree control interface. User can implement TreeControl to expand/collapse dataNodes in the tree.\n * The CDKTree will use this TreeControl to expand/collapse a node.\n * User can also use it outside the `<cdk-tree>` to control the expansion status of the tree.\n * @record\n * @template T, K\n */\n\n\nfunction TreeControl() {}\n\nif (false) {\n  /**\n   * The saved tree nodes data for `expandAll` action.\n   * @type {?}\n   */\n  TreeControl.prototype.dataNodes;\n  /**\n   * The expansion model\n   * @type {?}\n   */\n\n  TreeControl.prototype.expansionModel;\n  /**\n   * Get depth of a given data node, return the level number. This is for flat tree node.\n   * @type {?}\n   */\n\n  TreeControl.prototype.getLevel;\n  /**\n   * Whether the data node is expandable. Returns true if expandable.\n   * This is for flat tree node.\n   * @type {?}\n   */\n\n  TreeControl.prototype.isExpandable;\n  /**\n   * Gets a stream that emits whenever the given data node's children change.\n   * @type {?}\n   */\n\n  TreeControl.prototype.getChildren;\n  /**\n   * Whether the data node is expanded or collapsed. Return true if it's expanded.\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n  TreeControl.prototype.isExpanded = function (dataNode) {};\n  /**\n   * Get all descendants of a data node\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n\n  TreeControl.prototype.getDescendants = function (dataNode) {};\n  /**\n   * Expand or collapse data node\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n\n  TreeControl.prototype.toggle = function (dataNode) {};\n  /**\n   * Expand one data node\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n\n  TreeControl.prototype.expand = function (dataNode) {};\n  /**\n   * Collapse one data node\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n\n  TreeControl.prototype.collapse = function (dataNode) {};\n  /**\n   * Expand all the dataNodes in the tree\n   * @return {?}\n   */\n\n\n  TreeControl.prototype.expandAll = function () {};\n  /**\n   * Collapse all the dataNodes in the tree\n   * @return {?}\n   */\n\n\n  TreeControl.prototype.collapseAll = function () {};\n  /**\n   * Toggle a data node by expand/collapse it and all its descendants\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n\n  TreeControl.prototype.toggleDescendants = function (dataNode) {};\n  /**\n   * Expand a data node and all its descendants\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n\n  TreeControl.prototype.expandDescendants = function (dataNode) {};\n  /**\n   * Collapse a data node and all its descendants\n   * @param {?} dataNode\n   * @return {?}\n   */\n\n\n  TreeControl.prototype.collapseDescendants = function (dataNode) {};\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/outlet.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Injection token used to provide a `CdkTreeNode` to its outlet.\n * Used primarily to avoid circular imports.\n * \\@docs-private\n * @type {?}\n */\n\n\nvar CDK_TREE_NODE_OUTLET_NODE = new InjectionToken('CDK_TREE_NODE_OUTLET_NODE');\n/**\n * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\n\nvar CdkTreeNodeOutlet =\n/**\n * @param {?} viewContainer\n * @param {?=} _node\n */\nfunction CdkTreeNodeOutlet(viewContainer, _node) {\n  _classCallCheck(this, CdkTreeNodeOutlet);\n\n  this.viewContainer = viewContainer;\n  this._node = _node;\n};\n\nCdkTreeNodeOutlet.ɵfac = function CdkTreeNodeOutlet_Factory(t) {\n  return new (t || CdkTreeNodeOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(CDK_TREE_NODE_OUTLET_NODE, 8));\n};\n\nCdkTreeNodeOutlet.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkTreeNodeOutlet,\n  selectors: [[\"\", \"cdkTreeNodeOutlet\", \"\"]]\n});\n/** @nocollapse */\n\nCdkTreeNodeOutlet.ctorParameters = function () {\n  return [{\n    type: ViewContainerRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [CDK_TREE_NODE_OUTLET_NODE]\n    }, {\n      type: Optional\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(CdkTreeNodeOutlet, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTreeNodeOutlet]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ViewContainerRef\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [CDK_TREE_NODE_OUTLET_NODE]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\nif (false) {\n  /** @type {?} */\n  CdkTreeNodeOutlet.prototype.viewContainer;\n  /** @type {?} */\n\n  CdkTreeNodeOutlet.prototype._node;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/node.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Context provided to the tree node component.\n * @template T\n */\n\n\nvar CdkTreeNodeOutletContext =\n/**\n * @param {?} data\n */\nfunction CdkTreeNodeOutletContext(data) {\n  _classCallCheck(this, CdkTreeNodeOutletContext);\n\n  this.$implicit = data;\n};\n\nif (false) {\n  /**\n   * Data for the node.\n   * @type {?}\n   */\n  CdkTreeNodeOutletContext.prototype.$implicit;\n  /**\n   * Depth of the node.\n   * @type {?}\n   */\n\n  CdkTreeNodeOutletContext.prototype.level;\n  /**\n   * Index location of the node.\n   * @type {?}\n   */\n\n  CdkTreeNodeOutletContext.prototype.index;\n  /**\n   * Length of the number of total dataNodes.\n   * @type {?}\n   */\n\n  CdkTreeNodeOutletContext.prototype.count;\n}\n/**\n * Data node definition for the CdkTree.\n * Captures the node's template and a when predicate that describes when this node should be used.\n * @template T\n */\n\n\nvar CdkTreeNodeDef =\n/**\n * \\@docs-private\n * @param {?} template\n */\nfunction CdkTreeNodeDef(template) {\n  _classCallCheck(this, CdkTreeNodeDef);\n\n  this.template = template;\n};\n\nCdkTreeNodeDef.ɵfac = function CdkTreeNodeDef_Factory(t) {\n  return new (t || CdkTreeNodeDef)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n};\n\nCdkTreeNodeDef.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkTreeNodeDef,\n  selectors: [[\"\", \"cdkTreeNodeDef\", \"\"]],\n  inputs: {\n    when: [\"cdkTreeNodeDefWhen\", \"when\"]\n  }\n});\n/** @nocollapse */\n\nCdkTreeNodeDef.ctorParameters = function () {\n  return [{\n    type: TemplateRef\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(CdkTreeNodeDef, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTreeNodeDef]',\n      inputs: ['when: cdkTreeNodeDefWhen']\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.TemplateRef\n    }];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * Function that should return true if this node template should be used for the provided node\n   * data and index. If left undefined, this node will be considered the default node template to\n   * use when no other when functions return true for the data.\n   * For every node, there must be at least one when function that passes or an undefined to\n   * default.\n   * @type {?}\n   */\n  CdkTreeNodeDef.prototype.when;\n  /** @type {?} */\n\n  CdkTreeNodeDef.prototype.template;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/tree-errors.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Returns an error to be thrown when there is no usable data.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction getTreeNoValidDataSourceError() {\n  return Error(\"A valid data source must be provided.\");\n}\n/**\n * Returns an error to be thrown when there are multiple nodes that are missing a when function.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction getTreeMultipleDefaultNodeDefsError() {\n  return Error(\"There can only be one default row without a when predicate function.\");\n}\n/**\n * Returns an error to be thrown when there are no matching node defs for a particular set of data.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction getTreeMissingMatchingNodeDefError() {\n  return Error(\"Could not find a matching node definition for the provided node data.\");\n}\n/**\n * Returns an error to be thrown when there are tree control.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction getTreeControlMissingError() {\n  return Error(\"Could not find a tree control for the tree.\");\n}\n/**\n * Returns an error to be thrown when tree control did not implement functions for flat/nested node.\n * \\@docs-private\n * @return {?}\n */\n\n\nfunction getTreeControlFunctionsMissingError() {\n  return Error(\"Could not find functions for nested/flat tree in tree control.\");\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/tree.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * CDK tree component that connects with a data source to retrieve data of type `T` and renders\n * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.\n * @template T\n */\n\n\nvar CdkTree = /*#__PURE__*/function () {\n  /**\n   * @param {?} _differs\n   * @param {?} _changeDetectorRef\n   */\n  function CdkTree(_differs, _changeDetectorRef) {\n    _classCallCheck(this, CdkTree);\n\n    this._differs = _differs;\n    this._changeDetectorRef = _changeDetectorRef;\n    /**\n     * Subject that emits when the component has been destroyed.\n     */\n\n    this._onDestroy = new Subject();\n    /**\n     * Level of nodes\n     */\n\n    this._levels = new Map(); // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.\n    //     Remove the MAX_VALUE in viewChange\n\n    /**\n     * Stream containing the latest information on what rows are being displayed on screen.\n     * Can be used by the data source to as a heuristic of what data should be provided.\n     */\n\n    this.viewChange = new BehaviorSubject({\n      start: 0,\n      end: Number.MAX_VALUE\n    });\n  }\n  /**\n   * Provides a stream containing the latest data array to render. Influenced by the tree's\n   * stream of view window (what dataNodes are currently on screen).\n   * Data source can be an observable of data array, or a data array to render.\n   * @return {?}\n   */\n\n\n  _createClass(CdkTree, [{\n    key: \"ngOnInit\",\n\n    /**\n     * @return {?}\n     */\n    value: function ngOnInit() {\n      this._dataDiffer = this._differs.find([]).create(this.trackBy);\n\n      if (!this.treeControl) {\n        throw getTreeControlMissingError();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this._nodeOutlet.viewContainer.clear();\n\n      this.viewChange.complete();\n\n      this._onDestroy.next();\n\n      this._onDestroy.complete();\n\n      if (this._dataSource && typeof\n      /** @type {?} */\n      this._dataSource.disconnect === 'function') {\n        /** @type {?} */\n        this.dataSource.disconnect(this);\n      }\n\n      if (this._dataSubscription) {\n        this._dataSubscription.unsubscribe();\n\n        this._dataSubscription = null;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterContentChecked\",\n    value: function ngAfterContentChecked() {\n      /** @type {?} */\n      var defaultNodeDefs = this._nodeDefs.filter(\n      /**\n      * @param {?} def\n      * @return {?}\n      */\n      function (def) {\n        return !def.when;\n      });\n\n      if (defaultNodeDefs.length > 1) {\n        throw getTreeMultipleDefaultNodeDefsError();\n      }\n\n      this._defaultNodeDef = defaultNodeDefs[0];\n\n      if (this.dataSource && this._nodeDefs && !this._dataSubscription) {\n        this._observeRenderChanges();\n      }\n    } // TODO(tinayuangao): Work on keyboard traversal and actions, make sure it's working for RTL\n    //     and nested trees.\n\n    /**\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\n     * render change subscription if one exists. If the data source is null, interpret this by\n     * clearing the node outlet. Otherwise start listening for new data.\n     * @private\n     * @param {?} dataSource\n     * @return {?}\n     */\n\n  }, {\n    key: \"_switchDataSource\",\n    value: function _switchDataSource(dataSource) {\n      if (this._dataSource && typeof\n      /** @type {?} */\n      this._dataSource.disconnect === 'function') {\n        /** @type {?} */\n        this.dataSource.disconnect(this);\n      }\n\n      if (this._dataSubscription) {\n        this._dataSubscription.unsubscribe();\n\n        this._dataSubscription = null;\n      } // Remove the all dataNodes if there is now no data source\n\n\n      if (!dataSource) {\n        this._nodeOutlet.viewContainer.clear();\n      }\n\n      this._dataSource = dataSource;\n\n      if (this._nodeDefs) {\n        this._observeRenderChanges();\n      }\n    }\n    /**\n     * Set up a subscription for the data provided by the data source.\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"_observeRenderChanges\",\n    value: function _observeRenderChanges() {\n      var _this8 = this;\n\n      /** @type {?} */\n      var dataStream;\n\n      if (isDataSource(this._dataSource)) {\n        dataStream = this._dataSource.connect(this);\n      } else if (isObservable(this._dataSource)) {\n        dataStream = this._dataSource;\n      } else if (Array.isArray(this._dataSource)) {\n        dataStream = of(this._dataSource);\n      }\n\n      if (dataStream) {\n        this._dataSubscription = dataStream.pipe(takeUntil(this._onDestroy)).subscribe(\n        /**\n        * @param {?} data\n        * @return {?}\n        */\n        function (data) {\n          return _this8.renderNodeChanges(data);\n        });\n      } else {\n        throw getTreeNoValidDataSourceError();\n      }\n    }\n    /**\n     * Check for changes made in the data and render each change (node added/removed/moved).\n     * @param {?} data\n     * @param {?=} dataDiffer\n     * @param {?=} viewContainer\n     * @param {?=} parentData\n     * @return {?}\n     */\n\n  }, {\n    key: \"renderNodeChanges\",\n    value: function renderNodeChanges(data) {\n      var _this9 = this;\n\n      var dataDiffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._dataDiffer;\n      var viewContainer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._nodeOutlet.viewContainer;\n      var parentData = arguments.length > 3 ? arguments[3] : undefined;\n\n      /** @type {?} */\n      var changes = dataDiffer.diff(data);\n\n      if (!changes) {\n        return;\n      }\n\n      changes.forEachOperation(\n      /**\n      * @param {?} item\n      * @param {?} adjustedPreviousIndex\n      * @param {?} currentIndex\n      * @return {?}\n      */\n      function (item, adjustedPreviousIndex, currentIndex) {\n        if (item.previousIndex == null) {\n          _this9.insertNode(data[\n          /** @type {?} */\n          currentIndex],\n          /** @type {?} */\n          currentIndex, viewContainer, parentData);\n        } else if (currentIndex == null) {\n          viewContainer.remove(\n          /** @type {?} */\n          adjustedPreviousIndex);\n\n          _this9._levels.delete(item.item);\n        } else {\n          /** @type {?} */\n          var view = viewContainer.get(\n          /** @type {?} */\n          adjustedPreviousIndex);\n          viewContainer.move(\n          /** @type {?} */\n          view, currentIndex);\n        }\n      });\n\n      this._changeDetectorRef.detectChanges();\n    }\n    /**\n     * Finds the matching node definition that should be used for this node data. If there is only\n     * one node definition, it is returned. Otherwise, find the node definition that has a when\n     * predicate that returns true with the data. If none return true, return the default node\n     * definition.\n     * @param {?} data\n     * @param {?} i\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getNodeDef\",\n    value: function _getNodeDef(data, i) {\n      if (this._nodeDefs.length === 1) {\n        return this._nodeDefs.first;\n      }\n      /** @type {?} */\n\n\n      var nodeDef = this._nodeDefs.find(\n      /**\n      * @param {?} def\n      * @return {?}\n      */\n      function (def) {\n        return def.when && def.when(i, data);\n      }) || this._defaultNodeDef;\n\n      if (!nodeDef) {\n        throw getTreeMissingMatchingNodeDefError();\n      }\n\n      return nodeDef;\n    }\n    /**\n     * Create the embedded view for the data node template and place it in the correct index location\n     * within the data node view container.\n     * @param {?} nodeData\n     * @param {?} index\n     * @param {?=} viewContainer\n     * @param {?=} parentData\n     * @return {?}\n     */\n\n  }, {\n    key: \"insertNode\",\n    value: function insertNode(nodeData, index, viewContainer, parentData) {\n      /** @type {?} */\n      var node = this._getNodeDef(nodeData, index); // Node context that will be provided to created embedded view\n\n      /** @type {?} */\n\n\n      var context = new CdkTreeNodeOutletContext(nodeData); // If the tree is flat tree, then use the `getLevel` function in flat tree control\n      // Otherwise, use the level of parent node.\n\n      if (this.treeControl.getLevel) {\n        context.level = this.treeControl.getLevel(nodeData);\n      } else if (typeof parentData !== 'undefined' && this._levels.has(parentData)) {\n        context.level =\n        /** @type {?} */\n        this._levels.get(parentData) + 1;\n      } else {\n        context.level = 0;\n      }\n\n      this._levels.set(nodeData, context.level); // Use default tree nodeOutlet, or nested node's nodeOutlet\n\n      /** @type {?} */\n\n\n      var container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;\n      container.createEmbeddedView(node.template, context, index); // Set the data to just created `CdkTreeNode`.\n      // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable\n      //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.\n\n      if (CdkTreeNode.mostRecentTreeNode) {\n        CdkTreeNode.mostRecentTreeNode.data = nodeData;\n      }\n    }\n  }, {\n    key: \"dataSource\",\n    get: function get() {\n      return this._dataSource;\n    }\n    /**\n     * @param {?} dataSource\n     * @return {?}\n     */\n    ,\n    set: function set(dataSource) {\n      if (this._dataSource !== dataSource) {\n        this._switchDataSource(dataSource);\n      }\n    }\n  }]);\n\n  return CdkTree;\n}();\n\nCdkTree.ɵfac = function CdkTree_Factory(t) {\n  return new (t || CdkTree)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n};\n\nCdkTree.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: CdkTree,\n  selectors: [[\"cdk-tree\"]],\n  contentQueries: function CdkTree_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, CdkTreeNodeDef, true);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._nodeDefs = _t);\n    }\n  },\n  viewQuery: function CdkTree_Query(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵstaticViewQuery(CdkTreeNodeOutlet, true);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);\n    }\n  },\n  hostAttrs: [\"role\", \"tree\", 1, \"cdk-tree\"],\n  inputs: {\n    dataSource: \"dataSource\",\n    treeControl: \"treeControl\",\n    trackBy: \"trackBy\"\n  },\n  exportAs: [\"cdkTree\"],\n  decls: 1,\n  vars: 0,\n  consts: [[\"cdkTreeNodeOutlet\", \"\"]],\n  template: function CdkTree_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵelementContainer(0, 0);\n    }\n  },\n  directives: [CdkTreeNodeOutlet],\n  encapsulation: 2\n});\n/** @nocollapse */\n\nCdkTree.ctorParameters = function () {\n  return [{\n    type: IterableDiffers\n  }, {\n    type: ChangeDetectorRef\n  }];\n};\n\nCdkTree.propDecorators = {\n  dataSource: [{\n    type: Input\n  }],\n  treeControl: [{\n    type: Input\n  }],\n  trackBy: [{\n    type: Input\n  }],\n  _nodeOutlet: [{\n    type: ViewChild,\n    args: [CdkTreeNodeOutlet, {\n      static: true\n    }]\n  }],\n  _nodeDefs: [{\n    type: ContentChildren,\n    args: [CdkTreeNodeDef, {\n      // We need to use `descendants: true`, because Ivy will no longer match\n      // indirect descendants if it's left as false.\n      descendants: true\n    }]\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(CdkTree, [{\n    type: Component,\n    args: [{\n      selector: 'cdk-tree',\n      exportAs: 'cdkTree',\n      template: \"<ng-container cdkTreeNodeOutlet></ng-container>\",\n      host: {\n        'class': 'cdk-tree',\n        'role': 'tree'\n      },\n      encapsulation: ViewEncapsulation.None,\n      // The \"OnPush\" status for the `CdkTree` component is effectively a noop, so we are removing it.\n      // The view for `CdkTree` consists entirely of templates declared in other views. As they are\n      // declared elsewhere, they are checked when their declaration points are checked.\n      // tslint:disable-next-line:validate-decorators\n      changeDetection: ChangeDetectionStrategy.Default\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.IterableDiffers\n    }, {\n      type: ɵngcc0.ChangeDetectorRef\n    }];\n  }, {\n    dataSource: [{\n      type: Input\n    }],\n    treeControl: [{\n      type: Input\n    }],\n    trackBy: [{\n      type: Input\n    }],\n    _nodeOutlet: [{\n      type: ViewChild,\n      args: [CdkTreeNodeOutlet, {\n        static: true\n      }]\n    }],\n    _nodeDefs: [{\n      type: ContentChildren,\n      args: [CdkTreeNodeDef, {\n        // We need to use `descendants: true`, because Ivy will no longer match\n        // indirect descendants if it's left as false.\n        descendants: true\n      }]\n    }]\n  });\n})();\n\nif (false) {\n  /**\n   * Subject that emits when the component has been destroyed.\n   * @type {?}\n   * @private\n   */\n  CdkTree.prototype._onDestroy;\n  /**\n   * Differ used to find the changes in the data provided by the data source.\n   * @type {?}\n   * @private\n   */\n\n  CdkTree.prototype._dataDiffer;\n  /**\n   * Stores the node definition that does not have a when predicate.\n   * @type {?}\n   * @private\n   */\n\n  CdkTree.prototype._defaultNodeDef;\n  /**\n   * Data subscription\n   * @type {?}\n   * @private\n   */\n\n  CdkTree.prototype._dataSubscription;\n  /**\n   * Level of nodes\n   * @type {?}\n   * @private\n   */\n\n  CdkTree.prototype._levels;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  CdkTree.prototype._dataSource;\n  /**\n   * The tree controller\n   * @type {?}\n   */\n\n  CdkTree.prototype.treeControl;\n  /**\n   * Tracking function that will be used to check the differences in data changes. Used similarly\n   * to `ngFor` `trackBy` function. Optimize node operations by identifying a node based on its data\n   * relative to the function to know if a node should be added/removed/moved.\n   * Accepts a function that takes two parameters, `index` and `item`.\n   * @type {?}\n   */\n\n  CdkTree.prototype.trackBy;\n  /** @type {?} */\n\n  CdkTree.prototype._nodeOutlet;\n  /**\n   * The tree node template for the tree\n   * @type {?}\n   */\n\n  CdkTree.prototype._nodeDefs;\n  /**\n   * Stream containing the latest information on what rows are being displayed on screen.\n   * Can be used by the data source to as a heuristic of what data should be provided.\n   * @type {?}\n   */\n\n  CdkTree.prototype.viewChange;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  CdkTree.prototype._differs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  CdkTree.prototype._changeDetectorRef;\n}\n/**\n * Tree node for CdkTree. It contains the data in the tree node.\n * @template T\n */\n\n\nvar CdkTreeNode = /*#__PURE__*/function () {\n  /**\n   * @param {?} _elementRef\n   * @param {?} _tree\n   */\n  function CdkTreeNode(_elementRef, _tree) {\n    _classCallCheck(this, CdkTreeNode);\n\n    this._elementRef = _elementRef;\n    this._tree = _tree;\n    /**\n     * Subject that emits when the component has been destroyed.\n     */\n\n    this._destroyed = new Subject();\n    /**\n     * Emits when the node's data has changed.\n     */\n\n    this._dataChanges = new Subject();\n    /**\n     * The role of the node should be 'group' if it's an internal node,\n     * and 'treeitem' if it's a leaf node.\n     */\n\n    this.role = 'treeitem';\n    CdkTreeNode.mostRecentTreeNode =\n    /** @type {?} */\n    this;\n  }\n  /**\n   * The tree node's data.\n   * @return {?}\n   */\n\n\n  _createClass(CdkTreeNode, [{\n    key: \"ngOnDestroy\",\n\n    /**\n     * @return {?}\n     */\n    value: function ngOnDestroy() {\n      // If this is the last tree node being destroyed,\n      // clear out the reference to avoid leaking memory.\n      if (CdkTreeNode.mostRecentTreeNode === this) {\n        CdkTreeNode.mostRecentTreeNode = null;\n      }\n\n      this._dataChanges.complete();\n\n      this._destroyed.next();\n\n      this._destroyed.complete();\n    }\n    /**\n     * Focuses the menu item. Implements for FocusableOption.\n     * @return {?}\n     */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this._elementRef.nativeElement.focus();\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setRoleFromData\",\n    value: function _setRoleFromData() {\n      var _this10 = this;\n\n      if (this._tree.treeControl.isExpandable) {\n        this.role = this._tree.treeControl.isExpandable(this._data) ? 'group' : 'treeitem';\n      } else {\n        if (!this._tree.treeControl.getChildren) {\n          throw getTreeControlFunctionsMissingError();\n        }\n        /** @type {?} */\n\n\n        var childrenNodes = this._tree.treeControl.getChildren(this._data);\n\n        if (Array.isArray(childrenNodes)) {\n          this._setRoleFromChildren(\n          /** @type {?} */\n          childrenNodes);\n        } else if (isObservable(childrenNodes)) {\n          childrenNodes.pipe(takeUntil(this._destroyed)).subscribe(\n          /**\n          * @param {?} children\n          * @return {?}\n          */\n          function (children) {\n            return _this10._setRoleFromChildren(children);\n          });\n        }\n      }\n    }\n    /**\n     * @protected\n     * @param {?} children\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setRoleFromChildren\",\n    value: function _setRoleFromChildren(children) {\n      this.role = children && children.length ? 'group' : 'treeitem';\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this._data;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      if (value !== this._data) {\n        this._data = value;\n\n        this._setRoleFromData();\n\n        this._dataChanges.next();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"isExpanded\",\n    get: function get() {\n      return this._tree.treeControl.isExpanded(this._data);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"level\",\n    get: function get() {\n      return this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._data) : 0;\n    }\n  }]);\n\n  return CdkTreeNode;\n}();\n\nCdkTreeNode.ɵfac = function CdkTreeNode_Factory(t) {\n  return new (t || CdkTreeNode)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(CdkTree));\n};\n\nCdkTreeNode.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkTreeNode,\n  selectors: [[\"cdk-tree-node\"]],\n  hostAttrs: [1, \"cdk-tree-node\"],\n  hostVars: 3,\n  hostBindings: function CdkTreeNode_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"aria-expanded\", ctx.isExpanded)(\"aria-level\", ctx.role === \"treeitem\" ? ctx.level : null)(\"role\", ctx.role);\n    }\n  },\n  inputs: {\n    role: \"role\"\n  },\n  exportAs: [\"cdkTreeNode\"]\n});\n/**\n * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n * in `CdkTree` and set the data to it.\n */\n\nCdkTreeNode.mostRecentTreeNode = null;\n/** @nocollapse */\n\nCdkTreeNode.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: CdkTree\n  }];\n};\n\nCdkTreeNode.propDecorators = {\n  role: [{\n    type: Input\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(CdkTreeNode, [{\n    type: Directive,\n    args: [{\n      selector: 'cdk-tree-node',\n      exportAs: 'cdkTreeNode',\n      host: {\n        '[attr.aria-expanded]': 'isExpanded',\n        '[attr.aria-level]': 'role === \"treeitem\" ? level : null',\n        '[attr.role]': 'role',\n        'class': 'cdk-tree-node'\n      }\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: CdkTree\n    }];\n  }, {\n    role: [{\n      type: Input\n    }]\n  });\n})();\n\nif (false) {\n  /**\n   * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n   * in `CdkTree` and set the data to it.\n   * @type {?}\n   */\n  CdkTreeNode.mostRecentTreeNode;\n  /**\n   * Subject that emits when the component has been destroyed.\n   * @type {?}\n   * @protected\n   */\n\n  CdkTreeNode.prototype._destroyed;\n  /**\n   * Emits when the node's data has changed.\n   * @type {?}\n   */\n\n  CdkTreeNode.prototype._dataChanges;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CdkTreeNode.prototype._data;\n  /**\n   * The role of the node should be 'group' if it's an internal node,\n   * and 'treeitem' if it's a leaf node.\n   * @type {?}\n   */\n\n  CdkTreeNode.prototype.role;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CdkTreeNode.prototype._elementRef;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CdkTreeNode.prototype._tree;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/nested-node.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Nested node is a child of `<cdk-tree>`. It works with nested tree.\n * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will\n * be added in the `cdkTreeNodeOutlet` in tree node template.\n * The children of node will be automatically added to `cdkTreeNodeOutlet`.\n * @template T\n */\n\n\nvar CdkNestedTreeNode = /*#__PURE__*/function (_CdkTreeNode) {\n  _inherits(CdkNestedTreeNode, _CdkTreeNode);\n\n  var _super3 = _createSuper(CdkNestedTreeNode);\n\n  /**\n   * @param {?} _elementRef\n   * @param {?} _tree\n   * @param {?} _differs\n   */\n  function CdkNestedTreeNode(_elementRef, _tree, _differs) {\n    var _this11;\n\n    _classCallCheck(this, CdkNestedTreeNode);\n\n    _this11 = _super3.call(this, _elementRef, _tree);\n    _this11._elementRef = _elementRef;\n    _this11._tree = _tree;\n    _this11._differs = _differs;\n    return _this11;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(CdkNestedTreeNode, [{\n    key: \"ngAfterContentInit\",\n    value: function ngAfterContentInit() {\n      var _this12 = this;\n\n      this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);\n\n      if (!this._tree.treeControl.getChildren) {\n        throw getTreeControlFunctionsMissingError();\n      }\n      /** @type {?} */\n\n\n      var childrenNodes = this._tree.treeControl.getChildren(this.data);\n\n      if (Array.isArray(childrenNodes)) {\n        this.updateChildrenNodes(\n        /** @type {?} */\n        childrenNodes);\n      } else if (isObservable(childrenNodes)) {\n        childrenNodes.pipe(takeUntil(this._destroyed)).subscribe(\n        /**\n        * @param {?} result\n        * @return {?}\n        */\n        function (result) {\n          return _this12.updateChildrenNodes(result);\n        });\n      }\n\n      this.nodeOutlet.changes.pipe(takeUntil(this._destroyed)).subscribe(\n      /**\n      * @return {?}\n      */\n      function () {\n        return _this12.updateChildrenNodes();\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this._clear();\n\n      _get(_getPrototypeOf(CdkNestedTreeNode.prototype), \"ngOnDestroy\", this).call(this);\n    }\n    /**\n     * Add children dataNodes to the NodeOutlet\n     * @protected\n     * @param {?=} children\n     * @return {?}\n     */\n\n  }, {\n    key: \"updateChildrenNodes\",\n    value: function updateChildrenNodes(children) {\n      /** @type {?} */\n      var outlet = this._getNodeOutlet();\n\n      if (children) {\n        this._children = children;\n      }\n\n      if (outlet && this._children) {\n        /** @type {?} */\n        var viewContainer = outlet.viewContainer;\n\n        this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);\n      } else {\n        // Reset the data differ if there's no children nodes displayed\n        this._dataDiffer.diff([]);\n      }\n    }\n    /**\n     * Clear the children dataNodes.\n     * @protected\n     * @return {?}\n     */\n\n  }, {\n    key: \"_clear\",\n    value: function _clear() {\n      /** @type {?} */\n      var outlet = this._getNodeOutlet();\n\n      if (outlet) {\n        outlet.viewContainer.clear();\n\n        this._dataDiffer.diff([]);\n      }\n    }\n    /**\n     * Gets the outlet for the current node.\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"_getNodeOutlet\",\n    value: function _getNodeOutlet() {\n      var _this13 = this;\n\n      /** @type {?} */\n      var outlets = this.nodeOutlet; // Note that since we use `descendants: true` on the query, we have to ensure\n      // that we don't pick up the outlet of a child node by accident.\n\n      return outlets && outlets.find(\n      /**\n      * @param {?} outlet\n      * @return {?}\n      */\n      function (outlet) {\n        return !outlet._node || outlet._node === _this13;\n      });\n    }\n  }]);\n\n  return CdkNestedTreeNode;\n}(CdkTreeNode);\n\nCdkNestedTreeNode.ɵfac = function CdkNestedTreeNode_Factory(t) {\n  return new (t || CdkNestedTreeNode)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(CdkTree), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers));\n};\n\nCdkNestedTreeNode.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkNestedTreeNode,\n  selectors: [[\"cdk-nested-tree-node\"]],\n  contentQueries: function CdkNestedTreeNode_ContentQueries(rf, ctx, dirIndex) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵcontentQuery(dirIndex, CdkTreeNodeOutlet, true);\n    }\n\n    if (rf & 2) {\n      var _t;\n\n      ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nodeOutlet = _t);\n    }\n  },\n  hostAttrs: [1, \"cdk-tree-node\", \"cdk-nested-tree-node\"],\n  hostVars: 2,\n  hostBindings: function CdkNestedTreeNode_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"aria-expanded\", ctx.isExpanded)(\"role\", ctx.role);\n    }\n  },\n  exportAs: [\"cdkNestedTreeNode\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: CdkTreeNode,\n    useExisting: CdkNestedTreeNode\n  }, {\n    provide: CDK_TREE_NODE_OUTLET_NODE,\n    useExisting: CdkNestedTreeNode\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature]\n});\n/** @nocollapse */\n\nCdkNestedTreeNode.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: CdkTree\n  }, {\n    type: IterableDiffers\n  }];\n};\n\nCdkNestedTreeNode.propDecorators = {\n  nodeOutlet: [{\n    type: ContentChildren,\n    args: [CdkTreeNodeOutlet, {\n      // We need to use `descendants: true`, because Ivy will no longer match\n      // indirect descendants if it's left as false.\n      descendants: true\n    }]\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(CdkNestedTreeNode, [{\n    type: Directive,\n    args: [{\n      selector: 'cdk-nested-tree-node',\n      exportAs: 'cdkNestedTreeNode',\n      host: {\n        '[attr.aria-expanded]': 'isExpanded',\n        '[attr.role]': 'role',\n        'class': 'cdk-tree-node cdk-nested-tree-node'\n      },\n      providers: [{\n        provide: CdkTreeNode,\n        useExisting: CdkNestedTreeNode\n      }, {\n        provide: CDK_TREE_NODE_OUTLET_NODE,\n        useExisting: CdkNestedTreeNode\n      }]\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: CdkTree\n    }, {\n      type: ɵngcc0.IterableDiffers\n    }];\n  }, {\n    nodeOutlet: [{\n      type: ContentChildren,\n      args: [CdkTreeNodeOutlet, {\n        // We need to use `descendants: true`, because Ivy will no longer match\n        // indirect descendants if it's left as false.\n        descendants: true\n      }]\n    }]\n  });\n})();\n\nif (false) {\n  /**\n   * Differ used to find the changes in the data provided by the data source.\n   * @type {?}\n   * @private\n   */\n  CdkNestedTreeNode.prototype._dataDiffer;\n  /**\n   * The children data dataNodes of current node. They will be placed in `CdkTreeNodeOutlet`.\n   * @type {?}\n   * @protected\n   */\n\n  CdkNestedTreeNode.prototype._children;\n  /**\n   * The children node placeholder.\n   * @type {?}\n   */\n\n  CdkNestedTreeNode.prototype.nodeOutlet;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CdkNestedTreeNode.prototype._elementRef;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CdkNestedTreeNode.prototype._tree;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CdkNestedTreeNode.prototype._differs;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/padding.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Regex used to split a string on its CSS units.\n * @type {?}\n */\n\n\nvar cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * Indent for the children tree dataNodes.\n * This directive will add left-padding to the node to show hierarchy.\n * @template T\n */\n\nvar CdkTreeNodePadding = /*#__PURE__*/function () {\n  /**\n   * @param {?} _treeNode\n   * @param {?} _tree\n   * @param {?} _renderer\n   * @param {?} _element\n   * @param {?} _dir\n   */\n  function CdkTreeNodePadding(_treeNode, _tree,\n  /**\n   * @deprecated _renderer parameter no longer being used. To be removed.\n   * @breaking-change 11.0.0\n   */\n  _renderer, _element, _dir) {\n    var _this14 = this;\n\n    _classCallCheck(this, CdkTreeNodePadding);\n\n    this._treeNode = _treeNode;\n    this._tree = _tree;\n    this._element = _element;\n    this._dir = _dir;\n    /**\n     * Subject that emits when the component has been destroyed.\n     */\n\n    this._destroyed = new Subject();\n    /**\n     * CSS units used for the indentation value.\n     */\n\n    this.indentUnits = 'px';\n    this._indent = 40;\n\n    this._setPadding();\n\n    if (_dir) {\n      _dir.change.pipe(takeUntil(this._destroyed)).subscribe(\n      /**\n      * @return {?}\n      */\n      function () {\n        return _this14._setPadding(true);\n      });\n    } // In Ivy the indentation binding might be set before the tree node's data has been added,\n    // which means that we'll miss the first render. We have to subscribe to changes in the\n    // data to ensure that everything is up to date.\n\n\n    _treeNode._dataChanges.subscribe(\n    /**\n    * @return {?}\n    */\n    function () {\n      return _this14._setPadding();\n    });\n  }\n  /**\n   * The level of depth of the tree node. The padding will be `level * indent` pixels.\n   * @return {?}\n   */\n\n\n  _createClass(CdkTreeNodePadding, [{\n    key: \"ngOnDestroy\",\n\n    /**\n     * @return {?}\n     */\n    value: function ngOnDestroy() {\n      this._destroyed.next();\n\n      this._destroyed.complete();\n    }\n    /**\n     * The padding indent value for the tree node. Returns a string with px numbers if not null.\n     * @return {?}\n     */\n\n  }, {\n    key: \"_paddingIndent\",\n    value: function _paddingIndent() {\n      /** @type {?} */\n      var nodeLevel = this._treeNode.data && this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._treeNode.data) : null;\n      /** @type {?} */\n\n      var level = this._level == null ? nodeLevel : this._level;\n      return typeof level === 'number' ? \"\".concat(level * this._indent).concat(this.indentUnits) : null;\n    }\n    /**\n     * @param {?=} forceChange\n     * @return {?}\n     */\n\n  }, {\n    key: \"_setPadding\",\n    value: function _setPadding() {\n      var forceChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      /** @type {?} */\n      var padding = this._paddingIndent();\n\n      if (padding !== this._currentPadding || forceChange) {\n        /** @type {?} */\n        var element = this._element.nativeElement;\n        /** @type {?} */\n\n        var paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';\n        /** @type {?} */\n\n        var resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';\n        element.style[paddingProp] = padding || '';\n        element.style[resetProp] = '';\n        this._currentPadding = padding;\n      }\n    }\n  }, {\n    key: \"level\",\n    get: function get() {\n      return this._level;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      // Set to null as the fallback value so that _setPadding can fall back to the node level if the\n      // consumer set the directive as `cdkTreeNodePadding=\"\"`. We still want to take this value if\n      // they set 0 explicitly.\n      this._level =\n      /** @type {?} */\n      coerceNumberProperty(value, null);\n\n      this._setPadding();\n    }\n    /**\n     * The indent for each level. Can be a number or a CSS string.\n     * Default number 40px from material design menu sub-menu spec.\n     * @return {?}\n     */\n\n  }, {\n    key: \"indent\",\n    get: function get() {\n      return this._indent;\n    }\n    /**\n     * @param {?} indent\n     * @return {?}\n     */\n    ,\n    set: function set(indent) {\n      /** @type {?} */\n      var value = indent;\n      /** @type {?} */\n\n      var units = 'px';\n\n      if (typeof indent === 'string') {\n        /** @type {?} */\n        var parts = indent.split(cssUnitPattern);\n        value = parts[0];\n        units = parts[1] || units;\n      }\n\n      this.indentUnits = units;\n      this._indent = coerceNumberProperty(value);\n\n      this._setPadding();\n    }\n  }]);\n\n  return CdkTreeNodePadding;\n}();\n\nCdkTreeNodePadding.ɵfac = function CdkTreeNodePadding_Factory(t) {\n  return new (t || CdkTreeNodePadding)(ɵngcc0.ɵɵdirectiveInject(CdkTreeNode), ɵngcc0.ɵɵdirectiveInject(CdkTree), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Directionality, 8));\n};\n\nCdkTreeNodePadding.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkTreeNodePadding,\n  selectors: [[\"\", \"cdkTreeNodePadding\", \"\"]],\n  inputs: {\n    level: [\"cdkTreeNodePadding\", \"level\"],\n    indent: [\"cdkTreeNodePaddingIndent\", \"indent\"]\n  }\n});\n/** @nocollapse */\n\nCdkTreeNodePadding.ctorParameters = function () {\n  return [{\n    type: CdkTreeNode\n  }, {\n    type: CdkTree\n  }, {\n    type: Renderer2\n  }, {\n    type: ElementRef\n  }, {\n    type: Directionality,\n    decorators: [{\n      type: Optional\n    }]\n  }];\n};\n\nCdkTreeNodePadding.propDecorators = {\n  level: [{\n    type: Input,\n    args: ['cdkTreeNodePadding']\n  }],\n  indent: [{\n    type: Input,\n    args: ['cdkTreeNodePaddingIndent']\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(CdkTreeNodePadding, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTreeNodePadding]'\n    }]\n  }], function () {\n    return [{\n      type: CdkTreeNode\n    }, {\n      type: CdkTree\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc1.Directionality,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    level: [{\n      type: Input,\n      args: ['cdkTreeNodePadding']\n    }],\n    indent: [{\n      type: Input,\n      args: ['cdkTreeNodePaddingIndent']\n    }]\n  });\n})();\n\nif (false) {\n  /** @type {?} */\n  CdkTreeNodePadding.ngAcceptInputType_level;\n  /**\n   * Current padding value applied to the element. Used to avoid unnecessarily hitting the DOM.\n   * @type {?}\n   * @private\n   */\n\n  CdkTreeNodePadding.prototype._currentPadding;\n  /**\n   * Subject that emits when the component has been destroyed.\n   * @type {?}\n   * @private\n   */\n\n  CdkTreeNodePadding.prototype._destroyed;\n  /**\n   * CSS units used for the indentation value.\n   * @type {?}\n   */\n\n  CdkTreeNodePadding.prototype.indentUnits;\n  /** @type {?} */\n\n  CdkTreeNodePadding.prototype._level;\n  /** @type {?} */\n\n  CdkTreeNodePadding.prototype._indent;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  CdkTreeNodePadding.prototype._treeNode;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  CdkTreeNodePadding.prototype._tree;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  CdkTreeNodePadding.prototype._element;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  CdkTreeNodePadding.prototype._dir;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/toggle.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Node toggle to expand/collapse the node.\n * @template T\n */\n\n\nvar CdkTreeNodeToggle = /*#__PURE__*/function () {\n  /**\n   * @param {?} _tree\n   * @param {?} _treeNode\n   */\n  function CdkTreeNodeToggle(_tree, _treeNode) {\n    _classCallCheck(this, CdkTreeNodeToggle);\n\n    this._tree = _tree;\n    this._treeNode = _treeNode;\n    this._recursive = false;\n  }\n  /**\n   * Whether expand/collapse the node recursively.\n   * @return {?}\n   */\n\n\n  _createClass(CdkTreeNodeToggle, [{\n    key: \"_toggle\",\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n    // ViewEngine they're overwritten.\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n    // tslint:disable-next-line:no-host-decorator-in-concrete\n\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    value: function _toggle(event) {\n      this.recursive ? this._tree.treeControl.toggleDescendants(this._treeNode.data) : this._tree.treeControl.toggle(this._treeNode.data);\n      event.stopPropagation();\n    }\n  }, {\n    key: \"recursive\",\n    get: function get() {\n      return this._recursive;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this._recursive = coerceBooleanProperty(value);\n    }\n  }]);\n\n  return CdkTreeNodeToggle;\n}();\n\nCdkTreeNodeToggle.ɵfac = function CdkTreeNodeToggle_Factory(t) {\n  return new (t || CdkTreeNodeToggle)(ɵngcc0.ɵɵdirectiveInject(CdkTree), ɵngcc0.ɵɵdirectiveInject(CdkTreeNode));\n};\n\nCdkTreeNodeToggle.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: CdkTreeNodeToggle,\n  selectors: [[\"\", \"cdkTreeNodeToggle\", \"\"]],\n  hostBindings: function CdkTreeNodeToggle_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"click\", function CdkTreeNodeToggle_click_HostBindingHandler($event) {\n        return ctx._toggle($event);\n      });\n    }\n  },\n  inputs: {\n    recursive: [\"cdkTreeNodeToggleRecursive\", \"recursive\"]\n  }\n});\n/** @nocollapse */\n\nCdkTreeNodeToggle.ctorParameters = function () {\n  return [{\n    type: CdkTree\n  }, {\n    type: CdkTreeNode\n  }];\n};\n\nCdkTreeNodeToggle.propDecorators = {\n  recursive: [{\n    type: Input,\n    args: ['cdkTreeNodeToggleRecursive']\n  }],\n  _toggle: [{\n    type: HostListener,\n    args: ['click', ['$event']]\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(CdkTreeNodeToggle, [{\n    type: Directive,\n    args: [{\n      selector: '[cdkTreeNodeToggle]'\n    }]\n  }], function () {\n    return [{\n      type: CdkTree\n    }, {\n      type: CdkTreeNode\n    }];\n  }, {\n    recursive: [{\n      type: Input,\n      args: ['cdkTreeNodeToggleRecursive']\n    }],\n    _toggle: [{\n      type: HostListener,\n      args: ['click', ['$event']]\n    }]\n  });\n})();\n\nif (false) {\n  /** @type {?} */\n  CdkTreeNodeToggle.ngAcceptInputType_recursive;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CdkTreeNodeToggle.prototype._recursive;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CdkTreeNodeToggle.prototype._tree;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CdkTreeNodeToggle.prototype._treeNode;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/tree-module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar EXPORTED_DECLARATIONS = [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet];\n\nvar CdkTreeModule = function CdkTreeModule() {\n  _classCallCheck(this, CdkTreeModule);\n};\n\nCdkTreeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: CdkTreeModule\n});\nCdkTreeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function CdkTreeModule_Factory(t) {\n    return new (t || CdkTreeModule)();\n  },\n  providers: [FocusMonitor, CdkTreeNodeDef]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CdkTreeModule, {\n    declarations: [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet],\n    exports: [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet]\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(CdkTreeModule, [{\n    type: NgModule,\n    args: [{\n      exports: EXPORTED_DECLARATIONS,\n      declarations: EXPORTED_DECLARATIONS,\n      providers: [FocusMonitor, CdkTreeNodeDef]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: src/cdk/tree/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { BaseTreeControl, CDK_TREE_NODE_OUTLET_NODE, CdkNestedTreeNode, CdkTree, CdkTreeModule, CdkTreeNode, CdkTreeNodeDef, CdkTreeNodeOutlet, CdkTreeNodeOutletContext, CdkTreeNodePadding, CdkTreeNodeToggle, FlatTreeControl, NestedTreeControl, getTreeControlFunctionsMissingError, getTreeControlMissingError, getTreeMissingMatchingNodeDefError, getTreeMultipleDefaultNodeDefsError, getTreeNoValidDataSourceError };","map":{"version":3,"sources":["../../../../../cdk/tree/control/base-tree-control.ts","../../../../../cdk/tree/control/flat-tree-control.ts","../../../../../cdk/tree/control/nested-tree-control.ts","../../../../../cdk/tree/control/tree-control.ts","../../../../../cdk/tree/outlet.ts","../../../../../cdk/tree/node.ts","../../../../../cdk/tree/tree-errors.ts","../../../../../cdk/tree/tree.ts","../../../../../cdk/tree/nested-node.ts","../../../../../cdk/tree/padding.ts","../../../../../cdk/tree/toggle.ts","../../../../../cdk/tree/tree-module.ts","../../../../../cdk/tree/index.ts"],"names":["observableOf"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SelectionModel} from '@angular/cdk/collections';\nimport {Observable} from 'rxjs';\nimport {TreeControl} from './tree-control';\n\n/** Base tree control. It has basic toggle/expand/collapse operations on a single data node. */\nexport abstract class BaseTreeControl<T, K = T> implements TreeControl<T, K> {\n\n  /** Gets a list of descendent data nodes of a subtree rooted at given data node recursively. */\n  abstract getDescendants(dataNode: T): T[];\n\n  /** Expands all data nodes in the tree. */\n  abstract expandAll(): void;\n\n  /** Saved data node for `expandAll` action. */\n  dataNodes: T[];\n\n  /** A selection model with multi-selection to track expansion status. */\n  expansionModel: SelectionModel<K> = new SelectionModel<K>(true);\n\n  /**\n   * Returns the identifier by which a dataNode should be tracked, should its\n   * reference change.\n   *\n   * Similar to trackBy for *ngFor\n   */\n  trackBy?: (dataNode: T) => K;\n\n  /** Get depth of a given data node, return the level number. This is for flat tree node. */\n  getLevel: (dataNode: T) => number;\n\n  /**\n   * Whether the data node is expandable. Returns true if expandable.\n   * This is for flat tree node.\n   */\n  isExpandable: (dataNode: T) => boolean;\n\n  /** Gets a stream that emits whenever the given data node's children change. */\n  getChildren: (dataNode: T) => (Observable<T[]> | T[] | undefined | null);\n\n  /** Toggles one single data node's expanded/collapsed state. */\n  toggle(dataNode: T): void {\n    this.expansionModel.toggle(this._trackByValue(dataNode));\n  }\n\n  /** Expands one single data node. */\n  expand(dataNode: T): void {\n    this.expansionModel.select(this._trackByValue(dataNode));\n  }\n\n  /** Collapses one single data node. */\n  collapse(dataNode: T): void {\n    this.expansionModel.deselect(this._trackByValue(dataNode));\n  }\n\n  /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */\n  isExpanded(dataNode: T): boolean {\n    return this.expansionModel.isSelected(this._trackByValue(dataNode));\n  }\n\n  /** Toggles a subtree rooted at `node` recursively. */\n  toggleDescendants(dataNode: T): void {\n    this.expansionModel.isSelected(this._trackByValue(dataNode)) ?\n        this.collapseDescendants(dataNode) :\n        this.expandDescendants(dataNode);\n  }\n\n  /** Collapse all dataNodes in the tree. */\n  collapseAll(): void {\n    this.expansionModel.clear();\n  }\n\n  /** Expands a subtree rooted at given data node recursively. */\n  expandDescendants(dataNode: T): void {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.select(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n\n  /** Collapses a subtree rooted at given data node recursively. */\n  collapseDescendants(dataNode: T): void {\n    let toBeProcessed = [dataNode];\n    toBeProcessed.push(...this.getDescendants(dataNode));\n    this.expansionModel.deselect(...toBeProcessed.map(value => this._trackByValue(value)));\n  }\n\n  protected _trackByValue(value: T|K): K {\n    return this.trackBy ? this.trackBy(value as T) : value as K;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BaseTreeControl} from './base-tree-control';\n\n/** Optional set of configuration that can be provided to the FlatTreeControl. */\nexport interface FlatTreeControlOptions<T, K> {\n  trackBy?: (dataNode: T) => K;\n}\n\n/** Flat tree control. Able to expand/collapse a subtree recursively for flattened tree. */\nexport class FlatTreeControl<T, K = T> extends BaseTreeControl<T, K> {\n\n  /** Construct with flat tree data node functions getLevel and isExpandable. */\n  constructor(\n      public getLevel: (dataNode: T) => number, public isExpandable: (dataNode: T) => boolean,\n      public options?: FlatTreeControlOptions<T, K>) {\n    super();\n\n    if (this.options) {\n      this.trackBy = this.options.trackBy;\n    }\n  }\n\n  /**\n   * Gets a list of the data node's subtree of descendent data nodes.\n   *\n   * To make this working, the `dataNodes` of the TreeControl must be flattened tree nodes\n   * with correct levels.\n   */\n  getDescendants(dataNode: T): T[] {\n    const startIndex = this.dataNodes.indexOf(dataNode);\n    const results: T[] = [];\n\n    // Goes through flattened tree nodes in the `dataNodes` array, and get all descendants.\n    // The level of descendants of a tree node must be greater than the level of the given\n    // tree node.\n    // If we reach a node whose level is equal to the level of the tree node, we hit a sibling.\n    // If we reach a node whose level is greater than the level of the tree node, we hit a\n    // sibling of an ancestor.\n    for (let i = startIndex + 1;\n        i < this.dataNodes.length && this.getLevel(dataNode) < this.getLevel(this.dataNodes[i]);\n        i++) {\n      results.push(this.dataNodes[i]);\n    }\n    return results;\n  }\n\n  /**\n   * Expands all data nodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all flattened\n   * data nodes of the tree.\n   */\n  expandAll(): void {\n    this.expansionModel.select(...this.dataNodes.map(node => this._trackByValue(node)));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Observable, isObservable} from 'rxjs';\nimport {take, filter} from 'rxjs/operators';\nimport {BaseTreeControl} from './base-tree-control';\n\n/** Nested tree control. Able to expand/collapse a subtree recursively for NestedNode type. */\nexport class NestedTreeControl<T> extends BaseTreeControl<T> {\n\n  /** Construct with nested tree function getChildren. */\n  constructor(public getChildren: (dataNode: T) => (Observable<T[]> | T[] | undefined | null)) {\n    super();\n  }\n\n  /**\n   * Expands all dataNodes in the tree.\n   *\n   * To make this working, the `dataNodes` variable of the TreeControl must be set to all root level\n   * data nodes of the tree.\n   */\n  expandAll(): void {\n    this.expansionModel.clear();\n    const allNodes = this.dataNodes.reduce((accumulator: T[], dataNode) =>\n        [...accumulator, ...this.getDescendants(dataNode), dataNode], []);\n    this.expansionModel.select(...allNodes);\n  }\n\n  /** Gets a list of descendant dataNodes of a subtree rooted at given data node recursively. */\n  getDescendants(dataNode: T): T[] {\n    const descendants: T[] = [];\n\n    this._getDescendants(descendants, dataNode);\n    // Remove the node itself\n    return descendants.splice(1);\n  }\n\n  /** A helper function to get descendants recursively. */\n  protected _getDescendants(descendants: T[], dataNode: T): void {\n    descendants.push(dataNode);\n    const childrenNodes = this.getChildren(dataNode);\n    if (Array.isArray(childrenNodes)) {\n      childrenNodes.forEach((child: T) => this._getDescendants(descendants, child));\n    } else if (isObservable(childrenNodes)) {\n      // TypeScript as of version 3.5 doesn't seem to treat `Boolean` like a function that\n      // returns a `boolean` specifically in the context of `filter`, so we manually clarify that.\n      childrenNodes.pipe(take(1), filter(Boolean as () => boolean))\n          .subscribe(children => {\n            for (const child of children) {\n              this._getDescendants(descendants, child);\n            }\n          });\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SelectionModel} from '@angular/cdk/collections';\nimport {Observable} from 'rxjs';\n\n/**\n * Tree control interface. User can implement TreeControl to expand/collapse dataNodes in the tree.\n * The CDKTree will use this TreeControl to expand/collapse a node.\n * User can also use it outside the `<cdk-tree>` to control the expansion status of the tree.\n */\nexport interface TreeControl<T, K = T> {\n  /** The saved tree nodes data for `expandAll` action. */\n  dataNodes: T[];\n\n  /** The expansion model */\n  expansionModel: SelectionModel<K>;\n\n  /** Whether the data node is expanded or collapsed. Return true if it's expanded. */\n  isExpanded(dataNode: T): boolean;\n\n  /** Get all descendants of a data node */\n  getDescendants(dataNode: T): any[];\n\n  /** Expand or collapse data node */\n  toggle(dataNode: T): void;\n\n  /** Expand one data node */\n  expand(dataNode: T): void;\n\n  /** Collapse one data node */\n  collapse(dataNode: T): void;\n\n  /** Expand all the dataNodes in the tree */\n  expandAll(): void;\n\n  /** Collapse all the dataNodes in the tree */\n  collapseAll(): void;\n\n  /** Toggle a data node by expand/collapse it and all its descendants */\n  toggleDescendants(dataNode: T): void;\n\n  /** Expand a data node and all its descendants */\n  expandDescendants(dataNode: T): void;\n\n  /** Collapse a data node and all its descendants */\n  collapseDescendants(dataNode: T): void;\n\n  /** Get depth of a given data node, return the level number. This is for flat tree node. */\n  readonly getLevel: (dataNode: T) => number;\n\n  /**\n   * Whether the data node is expandable. Returns true if expandable.\n   * This is for flat tree node.\n   */\n  readonly isExpandable: (dataNode: T) => boolean;\n\n  /** Gets a stream that emits whenever the given data node's children change. */\n  readonly getChildren: (dataNode: T) => Observable<T[]> | T[] | undefined | null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  Directive,\n  Inject,\n  InjectionToken,\n  Optional,\n  ViewContainerRef,\n} from '@angular/core';\n\n/**\n * Injection token used to provide a `CdkTreeNode` to its outlet.\n * Used primarily to avoid circular imports.\n * @docs-private\n */\nexport const CDK_TREE_NODE_OUTLET_NODE = new InjectionToken<{}>('CDK_TREE_NODE_OUTLET_NODE');\n\n/**\n * Outlet for nested CdkNode. Put `[cdkTreeNodeOutlet]` on a tag to place children dataNodes\n * inside the outlet.\n */\n@Directive({\n  selector: '[cdkTreeNodeOutlet]'\n})\nexport class CdkTreeNodeOutlet {\n  constructor(\n      public viewContainer: ViewContainerRef,\n      @Inject(CDK_TREE_NODE_OUTLET_NODE) @Optional() public _node?: any) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, TemplateRef} from '@angular/core';\n\n\n/** Context provided to the tree node component. */\nexport class CdkTreeNodeOutletContext<T> {\n  /** Data for the node. */\n  $implicit: T;\n\n  /** Depth of the node. */\n  level: number;\n\n  /** Index location of the node. */\n  index?: number;\n\n  /** Length of the number of total dataNodes. */\n  count?: number;\n\n  constructor(data: T) {\n    this.$implicit = data;\n  }\n}\n\n/**\n * Data node definition for the CdkTree.\n * Captures the node's template and a when predicate that describes when this node should be used.\n */\n@Directive({\n  selector: '[cdkTreeNodeDef]',\n  inputs: [\n    'when: cdkTreeNodeDefWhen'\n  ],\n})\nexport class CdkTreeNodeDef<T> {\n  /**\n   * Function that should return true if this node template should be used for the provided node\n   * data and index. If left undefined, this node will be considered the default node template to\n   * use when no other when functions return true for the data.\n   * For every node, there must be at least one when function that passes or an undefined to\n   * default.\n   */\n  when: (index: number, nodeData: T) => boolean;\n\n  /** @docs-private */\n  constructor(public template: TemplateRef<any>) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Returns an error to be thrown when there is no usable data.\n * @docs-private\n */\nexport function getTreeNoValidDataSourceError() {\n  return Error(`A valid data source must be provided.`);\n}\n\n/**\n * Returns an error to be thrown when there are multiple nodes that are missing a when function.\n * @docs-private\n */\nexport function getTreeMultipleDefaultNodeDefsError() {\n  return Error(`There can only be one default row without a when predicate function.`);\n}\n\n/**\n * Returns an error to be thrown when there are no matching node defs for a particular set of data.\n * @docs-private\n */\nexport function getTreeMissingMatchingNodeDefError() {\n  return Error(`Could not find a matching node definition for the provided node data.`);\n}\n\n/**\n * Returns an error to be thrown when there are tree control.\n * @docs-private\n */\nexport function getTreeControlMissingError() {\n  return Error(`Could not find a tree control for the tree.`);\n}\n\n/**\n * Returns an error to be thrown when tree control did not implement functions for flat/nested node.\n * @docs-private\n */\nexport function getTreeControlFunctionsMissingError() {\n  return Error(`Could not find functions for nested/flat tree in tree control.`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {FocusableOption} from '@angular/cdk/a11y';\nimport {CollectionViewer, DataSource, isDataSource} from '@angular/cdk/collections';\nimport {\n  AfterContentChecked,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChildren,\n  Directive,\n  ElementRef,\n  Input,\n  IterableChangeRecord,\n  IterableDiffer,\n  IterableDiffers,\n  OnDestroy,\n  OnInit,\n  QueryList,\n  ViewChild,\n  ViewContainerRef,\n  ViewEncapsulation,\n  TrackByFunction\n} from '@angular/core';\nimport {\n  BehaviorSubject,\n  Observable,\n  of as observableOf,\n  Subject,\n  Subscription,\n  isObservable,\n} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\nimport {TreeControl} from './control/tree-control';\nimport {CdkTreeNodeDef, CdkTreeNodeOutletContext} from './node';\nimport {CdkTreeNodeOutlet} from './outlet';\nimport {\n  getTreeControlFunctionsMissingError,\n  getTreeControlMissingError,\n  getTreeMissingMatchingNodeDefError,\n  getTreeMultipleDefaultNodeDefsError,\n  getTreeNoValidDataSourceError\n} from './tree-errors';\n\n/**\n * CDK tree component that connects with a data source to retrieve data of type `T` and renders\n * dataNodes with hierarchy. Updates the dataNodes when new data is provided by the data source.\n */\n@Component({\n  selector: 'cdk-tree',\n  exportAs: 'cdkTree',\n  template: `<ng-container cdkTreeNodeOutlet></ng-container>`,\n  host: {\n    'class': 'cdk-tree',\n    'role': 'tree',\n  },\n  encapsulation: ViewEncapsulation.None,\n\n  // The \"OnPush\" status for the `CdkTree` component is effectively a noop, so we are removing it.\n  // The view for `CdkTree` consists entirely of templates declared in other views. As they are\n  // declared elsewhere, they are checked when their declaration points are checked.\n  // tslint:disable-next-line:validate-decorators\n  changeDetection: ChangeDetectionStrategy.Default\n})\nexport class CdkTree<T> implements AfterContentChecked, CollectionViewer, OnDestroy, OnInit {\n  /** Subject that emits when the component has been destroyed. */\n  private _onDestroy = new Subject<void>();\n\n  /** Differ used to find the changes in the data provided by the data source. */\n  private _dataDiffer: IterableDiffer<T>;\n\n  /** Stores the node definition that does not have a when predicate. */\n  private _defaultNodeDef: CdkTreeNodeDef<T> | null;\n\n  /** Data subscription */\n  private _dataSubscription: Subscription | null;\n\n  /** Level of nodes */\n  private _levels: Map<T, number> = new Map<T, number>();\n\n  /**\n   * Provides a stream containing the latest data array to render. Influenced by the tree's\n   * stream of view window (what dataNodes are currently on screen).\n   * Data source can be an observable of data array, or a data array to render.\n   */\n  @Input()\n  get dataSource(): DataSource<T> | Observable<T[]> | T[] { return this._dataSource; }\n  set dataSource(dataSource: DataSource<T> | Observable<T[]> | T[]) {\n    if (this._dataSource !== dataSource) {\n      this._switchDataSource(dataSource);\n    }\n  }\n  private _dataSource: DataSource<T> | Observable<T[]> | T[];\n\n  /** The tree controller */\n  @Input() treeControl: TreeControl<T>;\n\n  /**\n   * Tracking function that will be used to check the differences in data changes. Used similarly\n   * to `ngFor` `trackBy` function. Optimize node operations by identifying a node based on its data\n   * relative to the function to know if a node should be added/removed/moved.\n   * Accepts a function that takes two parameters, `index` and `item`.\n   */\n  @Input() trackBy: TrackByFunction<T>;\n\n  // Outlets within the tree's template where the dataNodes will be inserted.\n  @ViewChild(CdkTreeNodeOutlet, {static: true}) _nodeOutlet: CdkTreeNodeOutlet;\n\n  /** The tree node template for the tree */\n  @ContentChildren(CdkTreeNodeDef, {\n    // We need to use `descendants: true`, because Ivy will no longer match\n    // indirect descendants if it's left as false.\n    descendants: true\n  }) _nodeDefs: QueryList<CdkTreeNodeDef<T>>;\n\n  // TODO(tinayuangao): Setup a listener for scrolling, emit the calculated view to viewChange.\n  //     Remove the MAX_VALUE in viewChange\n  /**\n   * Stream containing the latest information on what rows are being displayed on screen.\n   * Can be used by the data source to as a heuristic of what data should be provided.\n   */\n  viewChange =\n    new BehaviorSubject<{start: number, end: number}>({start: 0, end: Number.MAX_VALUE});\n\n  constructor(private _differs: IterableDiffers,\n              private _changeDetectorRef: ChangeDetectorRef) {}\n\n  ngOnInit() {\n    this._dataDiffer = this._differs.find([]).create(this.trackBy);\n    if (!this.treeControl) {\n      throw getTreeControlMissingError();\n    }\n  }\n\n  ngOnDestroy() {\n    this._nodeOutlet.viewContainer.clear();\n\n    this.viewChange.complete();\n    this._onDestroy.next();\n    this._onDestroy.complete();\n\n    if (this._dataSource && typeof (this._dataSource as DataSource<T>).disconnect === 'function') {\n      (this.dataSource as DataSource<T>).disconnect(this);\n    }\n\n    if (this._dataSubscription) {\n      this._dataSubscription.unsubscribe();\n      this._dataSubscription = null;\n    }\n  }\n\n  ngAfterContentChecked() {\n    const defaultNodeDefs = this._nodeDefs.filter(def => !def.when);\n    if (defaultNodeDefs.length > 1) {\n      throw getTreeMultipleDefaultNodeDefsError();\n    }\n    this._defaultNodeDef = defaultNodeDefs[0];\n\n    if (this.dataSource && this._nodeDefs && !this._dataSubscription) {\n      this._observeRenderChanges();\n    }\n  }\n\n\n  // TODO(tinayuangao): Work on keyboard traversal and actions, make sure it's working for RTL\n  //     and nested trees.\n\n  /**\n   * Switch to the provided data source by resetting the data and unsubscribing from the current\n   * render change subscription if one exists. If the data source is null, interpret this by\n   * clearing the node outlet. Otherwise start listening for new data.\n   */\n  private _switchDataSource(dataSource: DataSource<T> | Observable<T[]> | T[]) {\n    if (this._dataSource && typeof (this._dataSource as DataSource<T>).disconnect === 'function') {\n      (this.dataSource as DataSource<T>).disconnect(this);\n    }\n\n    if (this._dataSubscription) {\n      this._dataSubscription.unsubscribe();\n      this._dataSubscription = null;\n    }\n\n    // Remove the all dataNodes if there is now no data source\n    if (!dataSource) {\n      this._nodeOutlet.viewContainer.clear();\n    }\n\n    this._dataSource = dataSource;\n    if (this._nodeDefs) {\n      this._observeRenderChanges();\n    }\n  }\n\n  /** Set up a subscription for the data provided by the data source. */\n  private _observeRenderChanges() {\n    let dataStream: Observable<T[] | ReadonlyArray<T>> | undefined;\n\n    if (isDataSource(this._dataSource)) {\n      dataStream = this._dataSource.connect(this);\n    } else if (isObservable(this._dataSource)) {\n      dataStream = this._dataSource;\n    } else if (Array.isArray(this._dataSource)) {\n      dataStream = observableOf(this._dataSource);\n    }\n\n    if (dataStream) {\n      this._dataSubscription = dataStream.pipe(takeUntil(this._onDestroy))\n        .subscribe(data => this.renderNodeChanges(data));\n    } else {\n      throw getTreeNoValidDataSourceError();\n    }\n  }\n\n  /** Check for changes made in the data and render each change (node added/removed/moved). */\n  renderNodeChanges(data: T[] | ReadonlyArray<T>, dataDiffer: IterableDiffer<T> = this._dataDiffer,\n                    viewContainer: ViewContainerRef = this._nodeOutlet.viewContainer,\n                    parentData?: T) {\n    const changes = dataDiffer.diff(data);\n    if (!changes) { return; }\n\n    changes.forEachOperation((item: IterableChangeRecord<T>,\n                              adjustedPreviousIndex: number | null,\n                              currentIndex: number | null) => {\n        if (item.previousIndex == null) {\n          this.insertNode(data[currentIndex!], currentIndex!, viewContainer, parentData);\n        } else if (currentIndex == null) {\n          viewContainer.remove(adjustedPreviousIndex!);\n          this._levels.delete(item.item);\n        } else {\n          const view = viewContainer.get(adjustedPreviousIndex!);\n          viewContainer.move(view!, currentIndex);\n        }\n      });\n\n    this._changeDetectorRef.detectChanges();\n  }\n\n  /**\n   * Finds the matching node definition that should be used for this node data. If there is only\n   * one node definition, it is returned. Otherwise, find the node definition that has a when\n   * predicate that returns true with the data. If none return true, return the default node\n   * definition.\n   */\n  _getNodeDef(data: T, i: number): CdkTreeNodeDef<T> {\n    if (this._nodeDefs.length === 1) { return this._nodeDefs.first; }\n\n    const nodeDef =\n      this._nodeDefs.find(def => def.when && def.when(i, data)) || this._defaultNodeDef;\n    if (!nodeDef) { throw getTreeMissingMatchingNodeDefError(); }\n\n    return nodeDef;\n  }\n\n  /**\n   * Create the embedded view for the data node template and place it in the correct index location\n   * within the data node view container.\n   */\n  insertNode(nodeData: T, index: number, viewContainer?: ViewContainerRef, parentData?: T) {\n    const node = this._getNodeDef(nodeData, index);\n\n    // Node context that will be provided to created embedded view\n    const context = new CdkTreeNodeOutletContext<T>(nodeData);\n\n    // If the tree is flat tree, then use the `getLevel` function in flat tree control\n    // Otherwise, use the level of parent node.\n    if (this.treeControl.getLevel) {\n      context.level = this.treeControl.getLevel(nodeData);\n    } else if (typeof parentData !== 'undefined' && this._levels.has(parentData)) {\n      context.level = this._levels.get(parentData)! + 1;\n    } else {\n      context.level = 0;\n    }\n    this._levels.set(nodeData, context.level);\n\n    // Use default tree nodeOutlet, or nested node's nodeOutlet\n    const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;\n    container.createEmbeddedView(node.template, context, index);\n\n    // Set the data to just created `CdkTreeNode`.\n    // The `CdkTreeNode` created from `createEmbeddedView` will be saved in static variable\n    //     `mostRecentTreeNode`. We get it from static variable and pass the node data to it.\n    if (CdkTreeNode.mostRecentTreeNode) {\n      CdkTreeNode.mostRecentTreeNode.data = nodeData;\n    }\n  }\n}\n\n\n/**\n * Tree node for CdkTree. It contains the data in the tree node.\n */\n@Directive({\n  selector: 'cdk-tree-node',\n  exportAs: 'cdkTreeNode',\n  host: {\n    '[attr.aria-expanded]': 'isExpanded',\n    '[attr.aria-level]': 'role === \"treeitem\" ? level : null',\n    '[attr.role]': 'role',\n    'class': 'cdk-tree-node',\n  },\n})\nexport class CdkTreeNode<T> implements FocusableOption, OnDestroy {\n  /**\n   * The most recently created `CdkTreeNode`. We save it in static variable so we can retrieve it\n   * in `CdkTree` and set the data to it.\n   */\n  static mostRecentTreeNode: CdkTreeNode<any> | null = null;\n\n  /** Subject that emits when the component has been destroyed. */\n  protected _destroyed = new Subject<void>();\n\n  /** Emits when the node's data has changed. */\n  _dataChanges = new Subject<void>();\n\n  /** The tree node's data. */\n  get data(): T { return this._data; }\n  set data(value: T) {\n    if (value !== this._data) {\n      this._data = value;\n      this._setRoleFromData();\n      this._dataChanges.next();\n    }\n  }\n  protected _data: T;\n\n  get isExpanded(): boolean {\n    return this._tree.treeControl.isExpanded(this._data);\n  }\n\n  get level(): number {\n    return this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._data) : 0;\n  }\n\n  /**\n   * The role of the node should be 'group' if it's an internal node,\n   * and 'treeitem' if it's a leaf node.\n   */\n  @Input() role: 'treeitem' | 'group' = 'treeitem';\n\n  constructor(protected _elementRef: ElementRef<HTMLElement>,\n              protected _tree: CdkTree<T>) {\n    CdkTreeNode.mostRecentTreeNode = this as CdkTreeNode<T>;\n  }\n\n  ngOnDestroy() {\n    // If this is the last tree node being destroyed,\n    // clear out the reference to avoid leaking memory.\n    if (CdkTreeNode.mostRecentTreeNode === this) {\n      CdkTreeNode.mostRecentTreeNode = null;\n    }\n\n    this._dataChanges.complete();\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /** Focuses the menu item. Implements for FocusableOption. */\n  focus(): void {\n    this._elementRef.nativeElement.focus();\n  }\n\n  protected _setRoleFromData(): void {\n    if (this._tree.treeControl.isExpandable) {\n      this.role = this._tree.treeControl.isExpandable(this._data) ? 'group' : 'treeitem';\n    } else {\n      if (!this._tree.treeControl.getChildren) {\n        throw getTreeControlFunctionsMissingError();\n      }\n      const childrenNodes = this._tree.treeControl.getChildren(this._data);\n      if (Array.isArray(childrenNodes)) {\n        this._setRoleFromChildren(childrenNodes as T[]);\n      } else if (isObservable(childrenNodes)) {\n        childrenNodes.pipe(takeUntil(this._destroyed))\n            .subscribe(children => this._setRoleFromChildren(children));\n      }\n    }\n  }\n\n  protected _setRoleFromChildren(children: T[]) {\n    this.role = children && children.length ? 'group' : 'treeitem';\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {\n  AfterContentInit,\n  ContentChildren,\n  Directive,\n  ElementRef,\n  IterableDiffer,\n  IterableDiffers,\n  OnDestroy,\n  QueryList,\n} from '@angular/core';\nimport {isObservable} from 'rxjs';\nimport {takeUntil} from 'rxjs/operators';\n\nimport {CDK_TREE_NODE_OUTLET_NODE, CdkTreeNodeOutlet} from './outlet';\nimport {CdkTree, CdkTreeNode} from './tree';\nimport {getTreeControlFunctionsMissingError} from './tree-errors';\n\n/**\n * Nested node is a child of `<cdk-tree>`. It works with nested tree.\n * By using `cdk-nested-tree-node` component in tree node template, children of the parent node will\n * be added in the `cdkTreeNodeOutlet` in tree node template.\n * The children of node will be automatically added to `cdkTreeNodeOutlet`.\n */\n@Directive({\n  selector: 'cdk-nested-tree-node',\n  exportAs: 'cdkNestedTreeNode',\n  host: {\n    '[attr.aria-expanded]': 'isExpanded',\n    '[attr.role]': 'role',\n    'class': 'cdk-tree-node cdk-nested-tree-node',\n  },\n  providers: [\n    {provide: CdkTreeNode, useExisting: CdkNestedTreeNode},\n    {provide: CDK_TREE_NODE_OUTLET_NODE, useExisting: CdkNestedTreeNode}\n  ]\n})\nexport class CdkNestedTreeNode<T> extends CdkTreeNode<T> implements AfterContentInit, OnDestroy {\n  /** Differ used to find the changes in the data provided by the data source. */\n  private _dataDiffer: IterableDiffer<T>;\n\n  /** The children data dataNodes of current node. They will be placed in `CdkTreeNodeOutlet`. */\n  protected _children: T[];\n\n  /** The children node placeholder. */\n  @ContentChildren(CdkTreeNodeOutlet, {\n    // We need to use `descendants: true`, because Ivy will no longer match\n    // indirect descendants if it's left as false.\n    descendants: true\n  })\n  nodeOutlet: QueryList<CdkTreeNodeOutlet>;\n\n  constructor(protected _elementRef: ElementRef<HTMLElement>,\n              protected _tree: CdkTree<T>,\n              protected _differs: IterableDiffers) {\n    super(_elementRef, _tree);\n  }\n\n  ngAfterContentInit() {\n    this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);\n    if (!this._tree.treeControl.getChildren) {\n      throw getTreeControlFunctionsMissingError();\n    }\n    const childrenNodes = this._tree.treeControl.getChildren(this.data);\n    if (Array.isArray(childrenNodes)) {\n      this.updateChildrenNodes(childrenNodes as T[]);\n    } else if (isObservable(childrenNodes)) {\n      childrenNodes.pipe(takeUntil(this._destroyed))\n        .subscribe(result => this.updateChildrenNodes(result));\n    }\n    this.nodeOutlet.changes.pipe(takeUntil(this._destroyed))\n        .subscribe(() => this.updateChildrenNodes());\n  }\n\n  ngOnDestroy() {\n    this._clear();\n    super.ngOnDestroy();\n  }\n\n  /** Add children dataNodes to the NodeOutlet */\n  protected updateChildrenNodes(children?: T[]): void {\n    const outlet = this._getNodeOutlet();\n    if (children) {\n      this._children = children;\n    }\n    if (outlet && this._children) {\n      const viewContainer = outlet.viewContainer;\n      this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);\n    } else {\n      // Reset the data differ if there's no children nodes displayed\n      this._dataDiffer.diff([]);\n    }\n  }\n\n  /** Clear the children dataNodes. */\n  protected _clear(): void {\n    const outlet = this._getNodeOutlet();\n    if (outlet) {\n      outlet.viewContainer.clear();\n      this._dataDiffer.diff([]);\n    }\n  }\n\n  /** Gets the outlet for the current node. */\n  private _getNodeOutlet() {\n    const outlets = this.nodeOutlet;\n\n    // Note that since we use `descendants: true` on the query, we have to ensure\n    // that we don't pick up the outlet of a child node by accident.\n    return outlets && outlets.find(outlet => !outlet._node || outlet._node === this);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directionality} from '@angular/cdk/bidi';\nimport {coerceNumberProperty, NumberInput} from '@angular/cdk/coercion';\nimport {Directive, ElementRef, Input, OnDestroy, Optional, Renderer2} from '@angular/core';\nimport {takeUntil} from 'rxjs/operators';\nimport {Subject} from 'rxjs';\nimport {CdkTree, CdkTreeNode} from './tree';\n\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n\n/**\n * Indent for the children tree dataNodes.\n * This directive will add left-padding to the node to show hierarchy.\n */\n@Directive({\n  selector: '[cdkTreeNodePadding]',\n})\nexport class CdkTreeNodePadding<T> implements OnDestroy {\n  /** Current padding value applied to the element. Used to avoid unnecessarily hitting the DOM. */\n  private _currentPadding: string|null;\n\n  /** Subject that emits when the component has been destroyed. */\n  private _destroyed = new Subject<void>();\n\n  /** CSS units used for the indentation value. */\n  indentUnits = 'px';\n\n  /** The level of depth of the tree node. The padding will be `level * indent` pixels. */\n  @Input('cdkTreeNodePadding')\n  get level(): number { return this._level; }\n  set level(value: number) {\n    // Set to null as the fallback value so that _setPadding can fall back to the node level if the\n    // consumer set the directive as `cdkTreeNodePadding=\"\"`. We still want to take this value if\n    // they set 0 explicitly.\n    this._level = coerceNumberProperty(value, null)!;\n    this._setPadding();\n  }\n  _level: number;\n\n  /**\n   * The indent for each level. Can be a number or a CSS string.\n   * Default number 40px from material design menu sub-menu spec.\n   */\n  @Input('cdkTreeNodePaddingIndent')\n  get indent(): number | string { return this._indent; }\n  set indent(indent: number | string) {\n    let value = indent;\n    let units = 'px';\n\n    if (typeof indent === 'string') {\n      const parts = indent.split(cssUnitPattern);\n      value = parts[0];\n      units = parts[1] || units;\n    }\n\n    this.indentUnits = units;\n    this._indent = coerceNumberProperty(value);\n    this._setPadding();\n  }\n  _indent: number = 40;\n\n  constructor(private _treeNode: CdkTreeNode<T>,\n              private _tree: CdkTree<T>,\n              /**\n               * @deprecated _renderer parameter no longer being used. To be removed.\n               * @breaking-change 11.0.0\n               */\n              _renderer: Renderer2,\n              private _element: ElementRef<HTMLElement>,\n              @Optional() private _dir: Directionality) {\n    this._setPadding();\n    if (_dir) {\n      _dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));\n    }\n\n    // In Ivy the indentation binding might be set before the tree node's data has been added,\n    // which means that we'll miss the first render. We have to subscribe to changes in the\n    // data to ensure that everything is up to date.\n    _treeNode._dataChanges.subscribe(() => this._setPadding());\n  }\n\n  ngOnDestroy() {\n    this._destroyed.next();\n    this._destroyed.complete();\n  }\n\n  /** The padding indent value for the tree node. Returns a string with px numbers if not null. */\n  _paddingIndent(): string|null {\n    const nodeLevel = (this._treeNode.data && this._tree.treeControl.getLevel)\n      ? this._tree.treeControl.getLevel(this._treeNode.data)\n      : null;\n    const level = this._level == null ? nodeLevel : this._level;\n    return typeof level === 'number' ? `${level * this._indent}${this.indentUnits}` : null;\n  }\n\n  _setPadding(forceChange = false) {\n    const padding = this._paddingIndent();\n\n    if (padding !== this._currentPadding || forceChange) {\n      const element = this._element.nativeElement;\n      const paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';\n      const resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';\n      element.style[paddingProp] = padding || '';\n      element.style[resetProp] = '';\n      this._currentPadding = padding;\n    }\n  }\n\n  static ngAcceptInputType_level: NumberInput;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {Directive, HostListener, Input} from '@angular/core';\n\nimport {CdkTree, CdkTreeNode} from './tree';\n\n/**\n * Node toggle to expand/collapse the node.\n */\n@Directive({selector: '[cdkTreeNodeToggle]'})\nexport class CdkTreeNodeToggle<T> {\n  /** Whether expand/collapse the node recursively. */\n  @Input('cdkTreeNodeToggleRecursive')\n  get recursive(): boolean { return this._recursive; }\n  set recursive(value: boolean) { this._recursive = coerceBooleanProperty(value); }\n  protected _recursive = false;\n\n  constructor(protected _tree: CdkTree<T>,\n              protected _treeNode: CdkTreeNode<T>) {}\n\n  // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n  // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n  // ViewEngine they're overwritten.\n  // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n  // tslint:disable-next-line:no-host-decorator-in-concrete\n  @HostListener('click', ['$event'])\n  _toggle(event: Event): void {\n    this.recursive\n      ? this._tree.treeControl.toggleDescendants(this._treeNode.data)\n      : this._tree.treeControl.toggle(this._treeNode.data);\n\n    event.stopPropagation();\n  }\n\n  static ngAcceptInputType_recursive: BooleanInput;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {FocusMonitor} from '@angular/cdk/a11y';\nimport {NgModule} from '@angular/core';\nimport {CdkTreeNodeOutlet} from './outlet';\nimport {CdkTreeNodePadding} from './padding';\nimport {CdkTreeNodeToggle} from './toggle';\nimport {CdkTree, CdkTreeNode} from './tree';\nimport {CdkTreeNodeDef} from './node';\nimport {CdkNestedTreeNode} from './nested-node';\n\nconst EXPORTED_DECLARATIONS = [\n  CdkNestedTreeNode,\n  CdkTreeNodeDef,\n  CdkTreeNodePadding,\n  CdkTreeNodeToggle,\n  CdkTree,\n  CdkTreeNode,\n  CdkTreeNodeOutlet,\n];\n\n@NgModule({\n  exports: EXPORTED_DECLARATIONS,\n  declarations: EXPORTED_DECLARATIONS,\n  providers: [FocusMonitor, CdkTreeNodeDef]\n})\nexport class CdkTreeModule {}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"]},"metadata":{},"sourceType":"module"}